from datetime import datetime

from telegram import InlineKeyboardButton, InlineKeyboardMarkup

import strings


def build_menu(buttons, n_cols, header_buttons=None, footer_buttons=None) -> list:
    # this function builds a telegram approved menu. it is a 2D matrix, with header and footer button support
    menu = [buttons[i:i + n_cols] for i in range(0, len(buttons), n_cols)]
    if header_buttons:
        menu.insert(0, [header_buttons])
    if footer_buttons:
        menu.append([footer_buttons])
    return menu


def group_setting_buttons(group, user_id):
    # this dict will contain the current settings later
    dynamic_strings = {"report": "", "reply": "", "mention": "", "administration": ""}
    # this will hold the current report triggers
    if group.admin:
        # if the @admin and /report triggers are active, both these settings will be true, so the string is Both
        if group.report:
            dynamic_strings["report"] = "Both"
        # since report is false, its only admin
        else:
            dynamic_strings["report"] = "@admin"
    # one trigger must be active, so it is only /report now
    else:
        dynamic_strings["report"] = "/report"
    # this will hold the current "bot replies in group setting
    if group.reply:
        dynamic_strings["reply"] = "✅"
    else:
        dynamic_strings["reply"] = "❌"
    # this will hold how the admin is mentioned.
    if user_id in group.pm:
        dynamic_strings["mention"] = "PM"
    elif user_id in group.off:
        dynamic_strings["mention"] = "Off"
    # if the user_id is not in off and not in pm, it means they want to be mentioned in the group
    elif user_id in group.admins:
        dynamic_strings["mention"] = "Mention"
    # this is a little joke, it will never happen in production. also, if I wouldn't set this, Pycharm complains
    else:
        dynamic_strings["mention"] = "❔"
    # this holds the the current setting if administration mode is active or not
    if group.administration:
        dynamic_strings["administration"] = "✅"
    else:
        dynamic_strings["administration"] = "❌"
    # this is a list with the buttons
    # the first param is the text, generated by taking from the string list and adding the current setting
    # the second is the data attached to the settings. they are unique strings
    buttons = [InlineKeyboardButton(strings.SETTINGS_BUTTONS[0] + dynamic_strings["report"],
                                    callback_data=strings.SETTINGS_BUTTONS_DATA[0]),
               InlineKeyboardButton(strings.SETTINGS_BUTTONS[1] + dynamic_strings["reply"],
                                    callback_data=strings.SETTINGS_BUTTONS_DATA[1]),
               InlineKeyboardButton(strings.SETTINGS_BUTTONS[2] + dynamic_strings["mention"],
                                    callback_data=strings.SETTINGS_BUTTONS_DATA[2]),
               InlineKeyboardButton(strings.SETTINGS_BUTTONS[3] + dynamic_strings["administration"],
                                    callback_data=strings.SETTINGS_BUTTONS_DATA[3]),
               InlineKeyboardButton(strings.SETTINGS_BUTTONS[5], callback_data=strings.SETTINGS_BUTTONS_DATA[5])]
    # we only need to show this setting if the administration mode is activated
    if group.administration:
        buttons.insert(4, InlineKeyboardButton(strings.SETTINGS_BUTTONS[4],
                                               callback_data=strings.SETTINGS_BUTTONS_DATA[4]))
    # here we return the build menu list
    return build_menu(buttons, 2)


def edit(update, group):
    # this function changes the setting message
    query = update.callback_query
    user_id = update.effective_user.id
    # we only have to change the buttons so that's what we tell telegram
    query.edit_message_reply_markup(InlineKeyboardMarkup(group_setting_buttons(group, user_id)))
    # this call is needed, otherwise some clients will show a loading indication
    query.answer()


def ceil_dt(dt, delta):
    return dt + (datetime.min - dt) % delta


def group_id_generator(groups):
    group_string = ""
    for index, group in enumerate(groups):
        group_string += f"\n{index}: {group.title}"
    return group_string
